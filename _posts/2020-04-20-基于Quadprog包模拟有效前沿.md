---
layout:     post
title:      基于quadprog包模拟5个资产的有效前沿
date:       2020-04-20
author:     Minjun Huang
header-img: img/tag-bg-o.jpg
catalog: true
tags:
    - R语言
    - 投资学原理
---

<head>
    <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
            tex2jax: {
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
            inlineMath: [['$','$']]
            }
        });
    </script>
</head>

## 两基金分离定理

该定理为作出有效前沿的理论基础。

&emsp;&emsp;对于一个有$n$种资产的投资组合，给定它们的历史*平均*收益率$\boldsymbol{r}=(\tilde{r}\_1,\cdots,\tilde{r}\_n)'$、各资产历史收益率的协方差矩阵$\boldsymbol{V}$及未来某一预期收益率$\text{E}(r)$，则存在权重矩阵$\boldsymbol{w}=(w\_1,\cdots,w\_n)'$使得当$\sum_{i}w\_{i}=1$且$\text{E}(r)=\boldsymbol{w}'\boldsymbol{r}$时，$\displaystyle \frac{1}{2}\boldsymbol{w}'\boldsymbol{Vw}$最小。转换为数学语言即

$$
\min_{\boldsymbol{w}} \frac{1}{2}\boldsymbol{w}'\boldsymbol{Vw}
$$

$$\begin{aligned}
\text{s}.\text{t}.\;&w_1+\cdots +w_n=1
\\
&w_1\tilde{r}_{1}+\cdots +w_{n}\tilde{r}_{n}=\text{E}\left( r \right) 
\end{aligned}
$$

> 证明参考Huang C.F. & Litzenberger R.H.所著的《Foundation for Financial Economics》。

## quadprog包的用法

&emsp;&emsp;`Quadprog`包可以用来解决二次规划的约束最优化问题。考虑以下约束最优化:

$$
\begin{aligned}
&q=\frac{1}{2}\boldsymbol{x}'\boldsymbol{Dx} - \boldsymbol{d}'\boldsymbol{x} + c
\\
&\text{s}.\text{t}. \boldsymbol{A}'\boldsymbol{x} \geqslant \boldsymbol{b}\_0
\end{aligned}
$$

其中$\boldsymbol{x}$为$n \times 1$的列向量，$\boldsymbol{D}$为$n$阶对称矩阵

## 在R语言中的实现

### 调取股票数据 

&emsp;&emsp;首先使用Tushare平台的接口调取工商银行、中国平安、中国人寿、中国太保和中证500在2014-01-01至2020-04-07的收盘价格。

```ruby
pacman::p_load(Tushare,tidyverse,tidyquant,quadprog)
#api <- pro_api(token = '') 已略去token

ICBC <- bar(ts_code='601398.SH',start_date="20140101",
            end_date='20200407',adj="qfq")
            
CSI500 <- api(api_name = 'index_daily',ts_code='000905.SH',start_date="20140101",
             end_date='20200407') 

PAIC <- bar(ts_code='601318.SH',start_date="20140101",
              end_date='20200407',adj="qfq")

CLI <- bar(ts_code='601628.SH',start_date="20140101",
            end_date='20200407',adj="qfq")

CPIC <- bar(ts_code='601601.SH',start_date="20140101",
            end_date='20200407',adj="qfq")
```
### 计算月收益率及协方差矩阵
&emsp;&emsp;利用`tidyquant`包计算月收益率，再通过`apply()`函数转化为5种资产的历史平均收益率，并使用`cov()`函数得到5种资产月收益率的协方差矩阵。
```ruby
return <- rbind(ICBC,CSI500,PAIC,CLI,CPIC) %>%
  select(ts_code,trade_date,close) %>% 
  mutate(trade_date = as.Date(trade_date,format="%Y%m%d"),close = as.numeric(close)) %>%
  group_by(ts_code) %>%
  tq_transmute(select = close,
               mutate_fun = periodReturn,
               period = 'monthly',
               col_rename = "Ra") %>%
  pivot_wider(names_from = ts_code,values_from = Ra) %>%
  select(-trade_date)

r <- c(apply(return,2,mean))
V <- cov(return)
```
### 进行约束最优化并作出有效前沿
```ruby
D <- 2*V
d <- rep(0,5)
A <- t(matrix(c(rep(1,5),rep(-1,5),r,-r),ncol=5,byrow=T))

ret <- c()
sd <- c()

for (i in seq(0.01,0.02,0.0005)){
  b0 = c(1,-1,i,-i)
  m = solve.QP(Dmat=D,dvec=d,Amat=A,bvec=b0,2)
  ret = append(ret,i) 
  sd = append(sd,sqrt(m$value)) ##optimal value under constraints
}
df <- tibble(ret,sd)

ggplot(df,aes(sd,ret)) +
  geom_point() +
  geom_line() +
  labs(x = 'Risk',y = 'Expected Rate of Return') +
  theme_bw()
```
![frontier](http://q92nu8xp6.bkt.clouddn.com/QQ%E6%88%AA%E5%9B%BE20200420135313.png)
